### H3 DRY, KISS i (nešto manje poznat) LOB princip

Ono što će najviše ljudi u branši da slepo prati je DRY princip. Nemojmo se ponavljati. Pišem sada o ovome principu jer je jedan od prvih principa koje usađujemo kada učimo programiranje, uz naravno KISS (zadržimo stvari jednostavnim), koji mislim da je neuporedivo korisniji, i često u suprotnosti sa DRY. Najveći problem programiranja je prenošenje apstrakcija u konkretno. Dakle, zahtevaoci imaju u vidu neku zamišljenu aplikaciju i upoznaju nas sa svojim zamislima. Mi zapravo čitavu aplikaciju gradimo na početnom sloju apstrakcije (koji je možda najteže prodreti), a to je naše shvatanje zahteva korisnika (ili zahtevaoca, koji često nisu isti ljudi, a ponašamo se kao da jesu). I stvarno, ovaj problem ne može da se zaobiđe, mi ne možemo da čitamo ničiji um, a ni sam zahtevalac verovatno nema toliko čvrstu predstavu o tome šta želi dok to što zamišlja ne pretvorimo u aplikaciju koju možemo iskusiti na nekom uređaju. 

Slepim poštovanjem DRY principa, mi po svaku cenu želimo da eliminišemo ponavljanje koda. Ukoliko više komponenti našeg sistema ima zajedničku, odnosno, i tu dolazi do "grešaka", dovoljno sličnu logiku, mi izvlačimo sličnosti i pakujemo u deljeno parče koda koje ćemo možda morati da proširimo ukoliko se pojavi naredna komponenta koja zahteva sličnu logiku (namerno ne govorim istu). Proširivanjem te zajedničke logike da primi sve slične zahteve mi zapravo kreiramo novi nivo apstrakcije. Mi se trudimo da uslišimo potrebu za deljenjem kvazi zajedničke logike, udaljujemo srž funkcionalnosti komponente u drugi kraj aplikacije, i vezujemo tu funkcionalnost sa komponentama koje nemaju nužno istu namenu. Ovde ne samo da kršimo princip LOB - Locality of behavior (kod koji je bukvalno vizuelno bliži jedno drugom je lakše razumeti i održavati), već kreiramo sparivanje (coupling) gde nema potrebe za sparivanjem. Kada kažemo "komponenta" zamišljamo nešto što je enkapsulirano, prenosivo i u najboljem slučaju "labavo spareno" sa ostalim komponentama sistema. Sparivanje na pogrešnom mestu narušava težnju ka labavo sparenim komponentama ukoliko se koristi u pogrešnom kontekstu. Sparivanje kao takvo je skoro neizbežno u većini sistema, ali ovde govorim o pogrešnom pristupu gde se ovo sparivanje bira kao prvi i ponekad jedini pristup problemu slične logike.

