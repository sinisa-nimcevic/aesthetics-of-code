## H2 Estetika koda

U svom delu "Rođenje tragedije", Fridrih Niče definiše Apolonijski i Dionizijski princip u starogrčkoj kulturi. Principi nazvani po dva božanstva predstavljaju dva suprotstavljena principa koja su i tek kako primenjiva o estetici. Najkraće rečeno, imamo Apolonijski prinicip iza kog stoje mirnoća, mnogo rezonovanja i dosta struktuirana forma, dok iza Dionizijskog principa stoji ekstatična, emotivna umetnost. U programerskim terminima bih tu pretpostavio bazu koda koja strogo poštuje OOP, sa SOLID principima i svime što Clean Code sugeriše kao predstavnika Apolonijskog principa, dok bih Dionisu prepustio divlji kod onog genijalnog (ali pomalo autističnog) kolege, koji sve rešava u 3 reda, koristeći najnoviju tehnologiju i rešenja koja su uglavnom samo njemu prisna.

Ovako ispisano, deluje da je Apolonijski princip jasan pobednik, međutim, smatram da praksa zahteva mnogo više "holistički" pristup. Programiranje zahteva kontekst, a slepo pridržavanje pravila bez konteksta je retko recept za optimalan užitak, motivaciju i što je najvažnije produktivnost programera. Produktivan programer je u mogućnosti da piše i prepisuje kod u bezbroj iteracija, nalazeći istinski "bolje" rešenje iz mnoštva uglova, dok programer zagušen pravilima i procedurama biva demotivisan, previše uplašen da bi unosio hrabre promene i uopšte usporen, ograničen u iteracijama i dostavi optimalnog rešenja (šta god definisali kao optimalno rešenje).

Lepota u Apolonijskom pristupu

Lepota u Apolonijskom pristupu je očigledna, bojim se površna u dosta slučajeva, ali nesumnjivo, proizvodimo na prvi pogled "lep" kod. Niz apstrakcija nas deli od "prljavih" implementacija, mnoštvo funkcija se ponavlja i smešteno je takođe, negde na klik ili dva u nekom "util" fajlu (odnosno, kojem god servis/factory/facade dizajn šablonu smo se priklonili), i generalno, komponente s kojima "moramo" da se sretnemo su ispunjene deklarativnim tonom kodiranja, i svedene na minimalno potreban broj redova. Delovi koji daju dodantu kompleksnost celini su izdvojeni te je implementacija većine logike enkapsulirana i spremna za ponovnu upotrebu. Imena funkcija i podkomponenti su dugačka, opisna i šablonski prepoznatljiva - koriste se pune reči umesto skraćenica i poređane su na konzistentan način. Kod je sofisticiran u strukturi, zahteva poznavanje baze, poznavanje korištenih principa i generalno kontemplaciju pre promene. Sam proces razvijanja mora da bude podređen mnogim proverama, kako statičkoj analizi, tako i budnom oku, jedne ili više osoba koje imaju dugoročno, ili barem dubokosežno poznavanje projekta, kako bi se struktura održala (lično smatram upliv nekog drugačijeg tipa koda u ove baze izuzetno ružnim). 

Ovakve baze koda odišu "čistoćom", i dok god sve funkcioniše kako treba su stvarno idejna oaza ozbiljnog softverskog inženjera sa dugogodišnjim iskustvom. Programer se mora "obreti" i "opeći" u haosu da bi stekao neophodno iskustvo da ovako nešto stvori i održava. Zahvaljujući definisanim softverskim šablonima dizajna i generalno poznatoj literaturi na koju se ovakva rešenja oslanjaju, iako postavljamo stepenicu za ulaz visoko, ona je dobro definisana i dostižna. 

Ono što vidim kao očigledne nedostatke ovakvih sistema je težnja ka suvišnim apstrakcijama (između ostalog). Apstrahovanjem delova koda da bismo dobiji čistije celine, mi udaljavamo izvršnu logiku od mesta gde se ona izvršava, a ponovnim korištenjem apstrakcija rizikujemo suvišno sparivanje koje nam se može obiti o glavu. Pogotovo ako prepoznajemo mesta za primenu spomenutih apstrakcija gde je kriterijum jedno arbitrarno "dovoljno slično", pa proširujemo apstrakcije dodatnim argumentima i atributima, odmičući se polako od originalne primene. Ovo stvara dalje komplikacije kada se usled stalnih promena od strane različitih programera (ili istih programera koji su dovoljno vremena proveli van projekta da im mentalni model logike izmiče iz sećanja). Kada neminovno naiđemo na kvarove, otklanjanje kvara nas vodi iz jedne apstrakcije u drugu, proveravamo gde je sve neka apstrakcija iskorištena i generalno moramo imati čitave dijagrame u glavi, ne bismo li bezbedno i precizno popravili baš onaj deo koda koji škripi. A kada konačno smislimo popravku, ona mora da prođe niz provera, kako od kolega, tako i od softvera i napisanih testova, da bi kod konačno osvanuo na produkciji. Iako nemam de fakto problem sa konzervativnim odnosom prema produkcionom kodu, smatram da dugo trajanje iteracije nikada nije dobra stvar (sem u retkim opravdanim slučajevima). Aplikacija nije u stanju da gradi momentum i, ukoliko imamo period brzih promena sa mnoštvom novih funkcionalnosti, programersko iskustvo rada pati, ispunjeno je (možda malim, ali) frustrirajućim pauzama i prepravkama, često samo radi održavanja forme.
